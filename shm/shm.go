package shm

// #include "shm.h"
import "C"
import (
	"os"
	"unsafe"
)

type VsysFlags int

// reference: https://man7.org/linux/man-pages/man2/shmget.2.html
/*
   The return value of the ftok function, or IPC_PRIVATE, is typically used to generate a unique identifier for a shared memory segment.
   When using IPC_PRIVATE, it is recommended that the two processes that will share the memory segment are related in some way, such as being parent and child processes.
   Otherwise, it may be difficult for another process to obtain the shared memory identifier (return value) generated by the current process.
*/
const (
	StatusIpcNone                = 0               // the constant with the value of 0 that represents no shared memory creation flag
	StatusIpcCreate    VsysFlags = C.IPC_CREAT     // the constant with the value of 512 that represents the flag for creating a new shared memory segment, defined as IPC_CREAT in C language
	StatusIpcExclusive           = C.IPC_EXCL      // the constant with the value of 1024 that represents the flag for creating a new shared memory segment exclusively
	StatusHugePages              = C.SHM_HUGETLB   // the constant with the value of 2048 that represents the flag for requesting shared memory allocation using huge pages.
	StatusNoReserve              = C.SHM_NORESERVE // the constant with the value of C.SHM_NORESERVE that represents the flag for creating a shared memory segment without reserving swap space.
)

type Error string

func (e Error) Error() string {
	return string(e)
}

// default value for shm
const (
	defautlShmFlag       = StatusIpcCreate | StatusIpcExclusive
	defaultShmPermission = 0600
)

const (
	ErrFailToRetrieveShmSize = Error("failed to retrieve shm size")
	ErrNegativeShmKey        = Error("shm key should not be negative")
	ErrEndOfFile             = Error("end of file")
	ErrIllegalKey            = Error("use Illegal key in shm")
	ErrDataDevided           = Error("data is divided into parts due to lack of space")
	ErrShmIdNotSet           = Error("shm id not set")
	ErrShmEmptyPoint         = Error("shm point is empty")
)

// Vsegment is a native representation of a SysV shared memory segment
type Vsegment struct {
	key    int64
	id     int64
	size   int64
	offset int64
}

type Vopts struct {
	Key       int64
	Size      int64
	Flag      VsysFlags
	Parameter os.FileMode
}

/*
New creates a new shared memory segment based on the given "Vopts" options.
It returns a pointer to a "Vsegment" variable and an error.
*/
func New(opts Vopts) (segment *Vsegment, err error) {
	switch {
	/*
		New creates a new shared memory segment based on the given "Vopts" options
		It returns a pointer to a "Vsegment" variable and an error
	*/
	case opts.Key > 0:
		if opts.Size > 0 {
			/*
				If the "size" field in the "opts" argument is also greater than 0,
				the function sets the "StatusIpcCreate" and "StatusIpcExclusive" flags in the "opts" argument
			*/
			opts.Flag = StatusIpcCreate | StatusIpcExclusive
		} else {
			/*
				If the "size" field in the "opts" argument is 0,
				the function sets the "StatusIpcNone" flag in the "opts" argument
			*/
			opts.Flag = StatusIpcNone
		}
		opts.Parameter = 0600
		segment, err = createShmWithKey(opts)
		return
	case opts.Key < 0:
		/*
			If the "key" field in the "opts" argument is less than 0,
			the function sets the "err" variable to an "ErrNegativeShmKey" error
		*/
		err = ErrNegativeShmKey
		return
	/*
		case opts.key == 0:

		I've done a lot of research, and it's not advised to use a key value of 0.
		[reference](https://hackmd.io/@sysprog/linux-shared-memory)
		If the "key" field in the "opts" argument is equal to 0,
		the function calls "createShm" to create a shared memory segment

		segment, err = createShm(opts)
	*/
	default:
		/*
			If the "key" field in the "opts" argument is equal to 0,
			the function sets the "err" variable to an "ErrIllegalKey" error
		*/
		err = ErrIllegalKey
	}
	return
}

// createShm to create a new shared memory segment with given size
func createShm(opts Vopts) (segment *Vsegment, err error) {
	// Declare variables to store shared memory ID and size
	var shmId C.int
	var shmSize C.ulong

	// Open shared memory segment with given size and default flags and permissions
	shmId, err = C.sysv_shm_open(C.int(opts.Size), C.int(defautlShmFlag), C.int(defaultShmPermission))
	if err == nil {
		// Retrieve the size of the shared memory segment
		shmSize, err = C.sysv_shm_get_size(shmId)

		// Return error if failed to retrieve the size
		if err != nil {
			err = ErrFailToRetrieveShmSize
			return
		}

		// Create a new Vsegment struct to represent the shared memory segment
		segment = &Vsegment{
			id:   int64(shmId),
			size: int64(shmSize),
		}
	}

	// Return the segment and err values
	return
}

// createShmWithKey to create a new shared memory segment with given size by using the key
func createShmWithKey(opts Vopts) (segment *Vsegment, err error) {
	// Declare variables to store shared memory ID and size
	var shmId C.int
	var shmSize C.ulong

	// Open shared memory segment with given size and default flags and permissions by using the key
	shmId, err = C.sysv_shm_open_with_key(C.int(opts.Key), C.int(opts.Size), C.int(opts.Flag), C.int(opts.Parameter))
	if err == nil {
		// Retrieve the size of the shared memory segment by using the key
		shmSize, err = C.sysv_shm_get_size(shmId)

		// Return error if failed to retrieve the size
		if err != nil {
			err = ErrFailToRetrieveShmSize
			return
		}

		// Create a new Vsegment struct to represent the shared memory segment by using the key
		segment = &Vsegment{
			key:  opts.Key,
			id:   int64(shmId),
			size: int64(shmSize),
		}
	}

	// Return the segment and err values
	return
}

// WriteWithId writes data to a shared memory segment and checks if the data to be written exceeds the available space in the segment.
// If the data to write is too large, it reduces the length to the remaining available space and sets a previous error variable.
func (receive *Vsegment) WriteWithId(data []byte) (wroteLength int64, err error) {
	// Check if the Vsegment pointer is nil
	if receive == nil {
		err = ErrShmEmptyPoint
	}

	// Check if the shared memory ID has been set
	if receive.id == 0 {
		err = ErrShmIdNotSet
		return
	}

	// Check if the current offset exceeds the size of the shared memory segment
	if receive.offset >= receive.size {
		err = ErrEndOfFile
		return
	}

	// Declare a variable to store an error returned by previous operations
	var previousErr error

	// Determine the length of the data to write
	wroteLength = int64(len(data))
	if (wroteLength + receive.offset) > receive.size {
		/*
			If the data to write exceeds the available space in the shared memory segment,
			reduce the wroteLength to the remaining available space and set the previous error variable to ErrDataDevided
		*/
		wroteLength = receive.size - receive.offset
		previousErr = ErrDataDevided
	}

	// Write the data to the shared memory segment
	_, err = C.sysv_shm_write(C.int(receive.id), unsafe.Pointer(&data[0]), C.int(wroteLength), C.int(receive.offset))
	if err != nil {
		// If an error occurs during the write operation, set the wroteLength to 0 and return
		wroteLength = 0
		return
	}

	// If the write operation is successful, update the offset and check if there was a previous error
	if err == nil {
		receive.offset += wroteLength
		if previousErr != nil {
			err = previousErr
		}
	}

	// Return the wroteLength and any error that occurred during the operation
	return
}

// ReadWithId is a function that reads data from a shared memory segment.
// It includes error checking and buffer allocation before reading data from shared memory.
func (receive *Vsegment) ReadWithId(data []byte) (readLength int, err error) {
	// Check if the Vsegment pointer is nil
	if receive == nil {
		err = ErrShmEmptyPoint
	}

	// Check if the shared memory ID has been set
	if receive.id == 0 {
		err = ErrShmIdNotSet
		return
	}

	// Check if the current offset exceeds the size of the shared memory segment
	if receive.offset >= receive.size {
		readLength = 0
		err = ErrEndOfFile
		return
	}

	// Calculate the actual number of bytes that can be read from the shared memory segment
	length := int64(len(data))
	if (length + receive.offset) > receive.size {
		length = receive.size - receive.offset
	}

	// Allocate a buffer for reading data from shared memory
	buffer := C.malloc(C.size_t(length))
	defer C.free(buffer)

	// Read data from shared memory
	_, err = C.sysv_shm_read(C.int(receive.id), buffer, C.int(length), C.int(receive.offset))
	if err != nil {
		readLength = 0
		return
	}

	// Copy the read data to the output buffer
	count := copy(data, C.GoBytes(buffer, C.int(length)))
	if count > 0 {
		receive.offset += int64(count)
		readLength = count
		return
	}

	// Return the number of bytes read and the error
	return
}
